# Общая архитектура приложения

Данный проект спроектирован с использованием принципов, схожих с Чистой Архитектурой (Clean Architecture) и Гексагональной Архитектурой (Ports and Adapters). Такой подход обеспечивает четкое разделение ответственностей, слабую связанность компонентов и высокую тестируемость кода.

## Основные слои

Архитектура разделена на несколько логических слоев:

1.  **Domain (Домен)**: Ядро приложения. Содержит бизнес-сущности, правила и логику, не зависящую от конкретных технологий и фреймворков.
2.  **Usecase (Сценарии использования)**: Оркестрирует поток данных и управляет бизнес-процессами. Использует доменные сущности и взаимодействует с внешним миром через абстрактные интерфейсы (порты).
3.  **Infrastructure (Инфраструктура)**: Содержит конкретные реализации интерфейсов, определенных в вышестоящих слоях. Это могут быть базы данных, внешние API, файловые системы и т.д. Этот слой зависит от всех остальных.
4.  **Presentation (Представление)**: Точка входа для пользователей или внешних систем. Отвечает за получение и отправку данных в удобном для клиента формате (например, JSON через HTTP).

---

## Обобщенная структура пакетов

```
/
├── cmd/                # Точки входа для сборки бинарных файлов (CLI, сервер)
│
├── internal/           # Вся основная логика приложения, инкапсулированная внутри проекта
│   │
│   ├── application/      # Сквозные компоненты: конфигурация, логгер, константы
│   │
│   ├── domain/           # Ядро бизнес-логики (Domain Layer)
│   │   ├── models/       # Бизнес-сущности и их логика
│   │   └── ...           # Другие доменные объекты: события, ошибки, значения
│   │
│   ├── usecase/          # Сценарии использования приложения (Application/Usecase Layer)
│   │   └── ...           # Определяют бизнес-процессы и интерфейсы для репозиториев
│   │
│   └── infra/            # Реализация инфраструктурных зависимостей (Infrastructure Layer)
│       ├── adapters/     # Конкретные реализации (адаптеры) для портов из usecase
│       │   ├── memory/   # Реализации, хранящие данные в памяти
│       │   └── postgres/ # Реализации для работы с базой данных
│       │
│       └── ports/        # Точки входа в приложение (порты)
│           └── http/     # Реализация транспортного уровня (например, HTTP)
│               ├── handlers/   # Обработчики запросов
│               ├── middleware/ # Промежуточное ПО
│               └── ...
│
├── web/                  # Статические файлы для фронтенда
│
├── deploy/               # Конфигурации для развертывания (Docker, CI/CD)
│
└── ...                   # Конфигурационные файлы проекта (go.mod, Dockerfile и т.д.)
```

## Обобщенный поток данных (Data Flow)

1.  **Внешний запрос**: Клиент (например, браузер) отправляет запрос на сервер.
2.  **Слой представления (`ports`)**: Маршрутизатор определяет, какой обработчик (`handler`) должен обработать этот запрос.
3.  **Обработчик (`handler`)**:
    *   Преобразует данные запроса в нейтральную структуру (DTO - Data Transfer Object).
    *   Вызывает соответствующий метод из слоя сценариев использования (`usecase`).
4.  **Слой сценариев использования (`usecase`)**:
    *   Выполняет основную бизнес-логику, координируя работу доменных моделей.
    *   Для доступа к данным вызывает методы репозитория через абстрактный интерфейс.
5.  **Слой инфраструктуры (`adapters`)**:
    *   Конкретная реализация репозитория выполняет операцию с источником данных (например, делает SQL-запрос к базе данных).
6.  **Ответ**: Результат возвращается по цепочке обратно: Repository -> Usecase -> Handler. Handler преобразует результат в формат, понятный клиенту (например, JSON), и отправляет HTTP-ответ.