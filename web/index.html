<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RoomSpeak</title>

    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>

    <style>
        /* Основные стили */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #36393f;
            color: #ffffff;
            margin: 0;
            padding: 20px;
        }

        /* Стили для формы */
        .connect_form {
            background-color: #2f3136;
            padding: 40px;
            border-radius: 20px;
            border: 1px solid #202225;
            max-width: 400px;
            margin: 0 auto;
        }

        label {
            display: block;
            margin-bottom: 15px;
        }

        input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #202225;
            border-radius: 4px;
            background-color: #40444b;
            color: #ffffff;
            font-size: 14px;
            outline: none;
            box-sizing: border-box;
        }

        input[type="text"]::placeholder {
            color: #72767d;
        }

        input[type="text"]:focus {
            border-color: #7289da;
        }

        button.connect {
            background-color: #7289da;
            color: #ffffff;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        button.disconnect {
            background-color: #7289da;
            color: #ffffff;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        button:disabled {
            background-color: #4a4e55;
            cursor: not-allowed;
        }

        button:hover:not(:disabled) {
            background-color: #677bc4;
        }

        /* Стили для списка участников */
        div[x-show="pc"] {
            background-color: #2f3136;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #202225;
            max-width: 400px;
            margin: 20px auto;
        }

        h3 {
            margin-top: 0;
            color: #ffffff;
        }

        ul {
            list-style: none;
            padding: 0;
        }

        li {
            padding: 8px;
            background-color: #40444b;
            border-radius: 4px;
            margin-bottom: 8px;
            color: #ffffff;
        }

        .room {
            max-width: 400px;
            margin: 0 auto;
        }

        /*Стили для состояния "Disconnected"*/
        div[x-show="!pc"] {
            text-align: center;
            color: #677bc4;
            margin-top: 20px;
        }

        /* Стили для select */
        select {
            width: 100%;
            padding: 10px;
            border: 1px solid #202225;
            border-radius: 4px;
            background-color: #40444b;
            color: #ffffff;
            font-size: 14px;
            outline: none;
            box-sizing: border-box;
            appearance: none; /* убираем системную стрелку */
            background-image: url("data:image/svg+xml;utf8,<svg fill='white' height='20' viewBox='0 0 24 24' width='20' xmlns='http://www.w3.org/2000/svg'><path d='M7 10l5 5 5-5z'/></svg>");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 16px;
            cursor: pointer;
        }

        /* При наведении */
        select:hover {
            border-color: #677bc4;
        }

        /* При фокусе */
        select:focus {
            border-color: #7289da;
        }

        /* Стили для опций */
        select option {
            background-color: #2f3136;
            color: #ffffff;
            padding: 10px;
        }

        /* Стили для видео */
        .video-container {
            background-color: #2f3136;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #202225;
            margin-bottom: 20px;
        }

        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .video-item {
            position: relative;
            background-color: #40444b;
            border-radius: 8px;
            overflow: hidden;
        }

        .video-item video {
            width: 100%;
            height: 150px;
            object-fit: cover;
            background-color: #2f3136;
        }

        .video-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.7);
            color: #ffffff;
            padding: 5px 10px;
            font-size: 12px;
            text-align: center;
        }

        /* Стили для чекбокса */
        input[type="checkbox"] {
            width: auto;
            margin-right: 10px;
        }
    </style>
</head>

<body x-data="app()" x-init="init()">

<div x-show="!pc" class="connect_form">
    <div>
        <label>
            <input
                    type="text"
                    placeholder="Your name"
                    x-model="name"
            >
        </label>

        <label>
            <input
                    type="text"
                    placeholder="Enter 4-symbol code"
                    x-model="roomCode"
                    @input="roomCode = $event.target.value.toUpperCase(); $event.target.value = roomCode"
                    maxlength="4"
            >
        </label>

        <!-- Чекбокс для включения видео -->
        <label style="display: flex; align-items: center; margin-bottom: 15px;">
            <input type="checkbox" x-model="enableVideo" @change="onVideoToggle()"
                   style="margin-right: 10px; width: auto;">
            <span>Enable Video</span>
        </label>

        <!-- Выбор устройства ввода -->
        <label>
            Audio Input:
            <select x-model="selectedInputDevice" @change="updateAudioDevices()">
                <template x-for="device in audioInputDevices">
                    <option :value="device.deviceId" x-text="device.label || 'Default Microphone'"></option>
                </template>
            </select>
        </label>

        <!-- Выбор видео устройства -->
        <label x-show="enableVideo">
            Video Input:
            <select x-model="selectedVideoDevice" @change="updateVideoDevices()">
                <template x-for="device in videoInputDevices">
                    <option :value="device.deviceId" x-text="device.label || 'Default Camera'"></option>
                </template>
            </select>
        </label>

        <!-- Выбор устройства вывода -->
        <label>
            Audio Output:
            <select x-model="selectedOutputDevice" @change="updateOutputDevice()">
                <template x-for="device in audioOutputDevices">
                    <option :value="device.deviceId" x-text="device.label || 'Default Speaker'"></option>
                </template>
            </select>
        </label>

        <button @click="connect()" :disabled="!isFormValid()" class="connect">Connect</button>
    </div>
</div>

<div class="room">
    <div x-show="pc">
        <!-- Видео участников -->
        <div class="video-container" x-show="enableVideo">
            <h3>Video Streams</h3>
            <div class="video-grid">
                <!-- Локальное видео -->
                <div class="video-item">
                    <video x-ref="localVideo" autoplay muted playsinline></video>
                    <div class="video-label">You</div>
                </div>
                <!-- Удаленные видео -->
                <template x-for="(stream, index) in remoteStreams" :key="index">
                    <div class="video-item">
                        <video :ref="`remoteVideo${index}`" autoplay playsinline></video>
                        <div class="video-label" x-text="`Participant ${index + 1}`"></div>
                    </div>
                </template>
            </div>
        </div>

        <h3>Participants</h3>
        <ul>
            <template x-for="participant in participants">
                <li x-text="participant"></li>
            </template>
        </ul>

        <button x-show="pc" @click="disconnect()" class="disconnect">Disconnect</button>
    </div>
</div>

<script>
    function app() {
        return {
            name: '',
            roomCode: '',
            enableVideo: false,

            audioInputDevices: [],
            audioOutputDevices: [],
            videoInputDevices: [],
            selectedInputDevice: '',
            selectedOutputDevice: '',
            selectedVideoDevice: '',
            currentAudioElement: null,

            ws: null,
            pingInterval: null,

            pc: null,
            localStream: null,
            remoteStreams: [],
            participants: [],

            isFormValid() {
                const re = /[A-Z0-9]{4}/;
                return this.name.trim().length > 0 && re.test(this.roomCode)
            },

            async init() {
                await this.getAudioDevices();
                // Обновляем список устройств при изменении
                navigator.mediaDevices.addEventListener('devicechange', () => this.getAudioDevices());
            },

            async getAudioDevices() {
                // Получаем разрешение на доступ к микрофону и камере (требуется для получения меток устройств)
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({audio: true, video: true});
                    stream.getTracks().forEach(track => track.stop());
                } catch (err) {
                    console.error('Error getting permissions:', err);
                }

                // Получаем список устройств
                const devices = await navigator.mediaDevices.enumerateDevices();

                this.audioInputDevices = devices.filter(d => d.kind === 'audioinput');
                this.audioOutputDevices = devices.filter(d => d.kind === 'audiooutput');
                this.videoInputDevices = devices.filter(d => d.kind === 'videoinput');

                if (this.audioInputDevices.length > 0 && !this.selectedInputDevice) {
                    this.selectedInputDevice = this.audioInputDevices[0].deviceId;
                }

                if (this.audioOutputDevices.length > 0 && !this.selectedOutputDevice) {
                    this.selectedOutputDevice = this.audioOutputDevices[0].deviceId;
                }

                if (this.videoInputDevices.length > 0 && !this.selectedVideoDevice) {
                    this.selectedVideoDevice = this.videoInputDevices[0].deviceId;
                }
            },

            async updateAudioDevices() {
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                }

                const constraints = {
                    audio: {
                        deviceId: this.selectedInputDevice ? {exact: this.selectedInputDevice} : undefined
                    }
                };

                this.localStream = await navigator.mediaDevices.getUserMedia(constraints);

                if (this.pc) {
                    const sender = this.pc.getSenders().find(s => s.track.kind === 'audio');
                    if (sender) {
                        sender.replaceTrack(this.localStream.getAudioTracks()[0]);
                    }
                }
            },

            async updateVideoDevices() {
                if (this.localStream) {
                    const videoTrack = this.localStream.getVideoTracks()[0];
                    if (videoTrack) {
                        videoTrack.stop();
                    }
                }

                if (this.enableVideo) {
                    const constraints = {
                        video: {
                            deviceId: this.selectedVideoDevice ? {exact: this.selectedVideoDevice} : undefined
                        }
                    };

                    const videoStream = await navigator.mediaDevices.getUserMedia(constraints);
                    const newVideoTrack = videoStream.getVideoTracks()[0];

                    if (this.localStream) {
                        this.localStream.addTrack(newVideoTrack);
                    }

                    if (this.pc) {
                        const sender = this.pc.getSenders().find(s => s.track.kind === 'video');
                        if (sender) {
                            sender.replaceTrack(newVideoTrack);
                        }
                    }

                    // Обновляем локальное видео
                    if (this.$refs.localVideo) {
                        this.$refs.localVideo.srcObject = this.localStream;
                    }
                }
            },

            async onVideoToggle() {
                if (this.enableVideo) {
                    // Включаем видео
                    if (this.localStream && this.pc) {
                        const constraints = {
                            video: {
                                deviceId: this.selectedVideoDevice ? {exact: this.selectedVideoDevice} : undefined
                            }
                        };

                        try {
                            const videoStream = await navigator.mediaDevices.getUserMedia(constraints);
                            const videoTrack = videoStream.getVideoTracks()[0];

                            this.localStream.addTrack(videoTrack);

                            // Добавляем видео трек в peer connection
                            const sender = this.pc.getSenders().find(s => s.track.kind === 'video');
                            if (sender) {
                                sender.replaceTrack(videoTrack);
                            } else {
                                this.pc.addTrack(videoTrack, this.localStream);
                            }

                            // Показываем локальное видео
                            if (this.$refs.localVideo) {
                                this.$refs.localVideo.srcObject = this.localStream;
                            }
                        } catch (err) {
                            console.error('Error enabling video:', err);
                            this.enableVideo = false;
                        }
                    }
                } else {
                    // Отключаем видео
                    if (this.localStream) {
                        const videoTrack = this.localStream.getVideoTracks()[0];
                        if (videoTrack) {
                            videoTrack.stop();
                            this.localStream.removeTrack(videoTrack);
                        }
                    }

                    if (this.pc) {
                        const sender = this.pc.getSenders().find(s => s.track.kind === 'video');
                        if (sender) {
                            this.pc.removeTrack(sender);
                        }
                    }

                    // Скрываем локальное видео
                    if (this.$refs.localVideo) {
                        this.$refs.localVideo.srcObject = null;
                    }
                }
            },

            async updateOutputDevice() {
                if (this.currentAudioElement && this.selectedOutputDevice) {
                    // Проверяем поддержку setSinkId
                    if ('setSinkId' in this.currentAudioElement) {
                        this.currentAudioElement.setSinkId(this.selectedOutputDevice)
                            .catch(err => console.error('Error setting audio output:', err));
                    }
                }
            },


            async connect() {
                try {
                    await this.initializeWebSocket();
                    await this.initializeWebRTC();
                } catch (err) {
                    console.error('Connection error:', err);
                    alert('Connection failed: ' + err.message);
                }
            },

            async initializeWebSocket() {
                // TODO убрать залупу
                this.ws = new WebSocket(`${window.location.protocol === 'https:' ? 'wss' : 'ws'}://${window.location.host}/ws`);

                return new Promise((resolve, reject) => {
                    this.ws.onopen = () => {
                        this.ws.send(JSON.stringify({
                            type: 'join',
                            data: {name: this.name, room_id: this.roomCode}
                        }));
                        // ping-pong для поддержания соединения
                        this.pingInterval = setInterval(() => {
                            if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                                this.ws.send(JSON.stringify({type: "ping"}));
                            }
                        }, 30000); // каждые 30 сек

                        resolve();
                    };

                    this.ws.onerror = (err) => reject(err);

                    this.ws.onmessage = (event) => this.handleWSMessage(event);

                    this.ws.onclose = () => {
                        clearInterval(this.pingInterval);
                        this.pingInterval = null;
                        if (this.pc) this.disconnect();
                        alert('Connection closed');
                    };
                });
            },

            async initializeWebRTC() {
                this.pc = new RTCPeerConnection({
                    // TODO: add temp turn creds
                    iceServers: [
                        {urls: 'stun:stun.l.google.com:19302'},
                        {
                            urls: "turn:global.relay.metered.ca:80",
                            username: "faaedb0c03ab57b3f89db765",
                            credential: "oIWUwz8UMiKfeC5Z",
                        }
                    ]
                });

                // Настройка обработчиков WebRTC
                this.pc.onicecandidate = (e) => {
                    if (e.candidate) {
                        this.ws.send(JSON.stringify({
                            type: 'candidate',
                            data: {
                                candidate: e.candidate
                            }
                        }));
                    }
                };

                // Используем выбранное устройство ввода
                const constraints = {
                    audio: {
                        deviceId: this.selectedInputDevice ? {exact: this.selectedInputDevice} : undefined
                    }
                };

                // Добавляем видео если включено
                if (this.enableVideo) {
                    constraints.video = {
                        deviceId: this.selectedVideoDevice ? {exact: this.selectedVideoDevice} : undefined
                    };
                }

                // Получение медиа потока
                this.localStream = await navigator.mediaDevices.getUserMedia(constraints);

                // Добавляем треки в peer connection
                this.localStream.getTracks().forEach(track => {
                    this.pc.addTrack(track, this.localStream);
                });

                // Показываем локальное видео если включено
                if (this.enableVideo && this.$refs.localVideo) {
                    this.$refs.localVideo.srcObject = this.localStream;
                }

                // Обработка входящих треков
                this.pc.ontrack = (event) => {
                    if (event.track.kind === 'audio') {
                        const audio = new Audio();
                        audio.srcObject = event.streams[0];

                        // Устанавливаем выбранное устройство вывода
                        if (this.selectedOutputDevice && 'setSinkId' in audio) {
                            audio.setSinkId(this.selectedOutputDevice)
                                .catch(err => console.error('Error setting audio output:', err));
                        }

                        audio.play();
                    } else if (event.track.kind === 'video' && this.enableVideo) {
                        // Добавляем видео поток в массив удаленных потоков
                        this.remoteStreams.push(event.streams[0]);

                        // Обновляем DOM для отображения видео
                        this.$nextTick(() => {
                            const videoIndex = this.remoteStreams.length - 1;
                            const videoElement = this.$refs[`remoteVideo${videoIndex}`];
                            if (videoElement) {
                                videoElement.srcObject = event.streams[0];
                            }
                        });
                    }
                };

                const offer = await this.pc.createOffer();
                await this.pc.setLocalDescription(offer);
                this.ws.send(JSON.stringify({
                    type: 'offer',
                    data: {
                        sdp: offer.sdp
                    }
                }));
            },

            async handleWSMessage(event) {
                const message = JSON.parse(event.data);

                switch (message.type) {
                    case 'offer':
                        await this.pc.setRemoteDescription(message);
                        const answer = await this.pc.createAnswer();
                        await this.pc.setLocalDescription(answer);
                        this.ws.send(JSON.stringify({
                            type: 'offer',
                            data: {
                                sdp: answer.sdp
                            }
                        }));
                        break;

                    case 'answer':
                        await this.pc.setRemoteDescription(message);
                        break;

                    case 'candidate':
                        try {
                            await this.pc.addIceCandidate(message.candidate);
                        } catch (err) {
                            console.error('Error adding ICE candidate:', err);
                        }
                        break;
                    case 'participants':
                        this.updateParticipants(message.list);
                        break;
                    case 'error':
                        console.error('Server error:', message.message);
                        alert('Server error: ' + message.message);
                        this.disconnect();
                        break;
                    case 'pong':
                        console.log('Pong received');
                        break;

                    default:
                        console.warn('Unknown message type:', message.type);
                }
            },

            updateParticipants(participants) {
                this.participants = participants
            },

            disconnect() {
                if (this.pc) {
                    this.pc.close();
                    this.pc = null;
                }

                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }

                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                    this.localStream = null;
                }

                // Очищаем удаленные видео потоки
                this.remoteStreams.forEach(stream => {
                    stream.getTracks().forEach(track => track.stop());
                });
                this.remoteStreams = [];

                // Очищаем видео элементы
                if (this.$refs.localVideo) {
                    this.$refs.localVideo.srcObject = null;
                }
            }
        }
    }
</script>

</body>
</html>